<!DOCTYPE html>
<head>
<title>Roomba Battle</title>

<style>
#container {
    position: fixed;
    top: 0px;
    left: 0px;
    width: 100vw;
    height: 100vh;
}

.player .body {
    fill: rgb(20, 20, 255);
    stroke: rgb(0, 0, 255);
    stroke-width: 1px;
    opacity: 0.25;
}

.player.shocked .body {
    fill: orange;
}

.player.dead .body {
    fill: red;
}

.player .head {
    fill: rgb(100, 100, 255);
}

.player.shock .head {
    fill: yellow;
    stroke: yellow;
    stroke-width: 4px;
}

.player text {
    font-family: monospace;
    text-shadow: 1px 1px 2px rgb(111, 111, 111);
}

.player text.label {
    fill: white;
    font-weight: bold;
    font-size: 32px;
    text-decoration: underline;
}

.player text.energy {
    fill: rgb(55, 55, 55);
    font-size: 24px;
    transform: translate(10px, 45px);
}
</style>
</head>
<body>

<script src="https://d3js.org/d3.v4.min.js"></script>

<svg id='container'></svg>
<button id='stop' style='position: fixed; opacity: 0.5'>Stop</button>

<script>
const roombaRadius = 60;
const headRadius = roombaRadius / 8;
const startingEnergy = 1000;
const shockEnergyCost = 7;
const shockDamage = 80;
const healingRate = 5;
const speed = 10;
const frameRate = Math.floor(1000 / 30);
const players = [];

var nextPlayerId = 10;

function addPlayer(generator){
    const player = {
        id: nextPlayerId++,
        energy: startingEnergy,
        position: {
            x: Math.floor(Math.random() * window.innerWidth),
            y: Math.floor(Math.random() * window.innerHeight)
        },
        io: {
            faceAngle: 0,
        }
    };

    player.iterator = generator(player.io);

    players.push(player);
}

function constrainPosition(max, actual){
    const padding = roombaRadius;
    max -= padding;

    if (actual > max){
        return max;
    }
    else if (actual < padding){
        return padding;
    }
    else {
        return actual;
    }
}

function calculateAngle(x1, y1, x2, y2){
	return Math.atan2(y1 - y2, x1 - x2);
}

function calculateDistance(x1, y1, x2, y2){
	return Math.sqrt(((x2 - x1)**2) + ((y2 - y1)**2));
}

function calculateOverlap(x1, y1, r1, x2, y2, r2){
    const distance = calculateDistance(x1, y1, x2, y2);
    if (distance >= r1 + r2){
    	return 0;
    }
    else {
    	return (r1 + r2) - distance;
    }
}

var stopped = false;
document.getElementById('stop').addEventListener('click', () => stopped = true);

const container = d3.select('#container');

async function run(){
    while (!stopped){
        const playerPositions = {};
        for (const player of players){
            playerPositions[player.id] = Object.freeze(Object.assign({}, player.position))
        }
        Object.freeze(playerPositions);

        const arena = Object.freeze({
            width: window.innerWidth,
            height: window.innerHeight
        });

        const dataJoin = container.selectAll('.player:not(.dead)').data(players, d => d.id);

        dataJoin.exit()
            .classed('dead', true)
            .transition()
                .duration(1000)
                .style('opacity', 0)
                .remove();

        const g =
            dataJoin.enter()
            .append('g')
                .attr('class', 'player')
                .style('opacity', 0);

        const innerG = g.append('g').attr('class', 'inner');

        innerG.append('circle')
            .attr('class', 'body')
            .attr('r', roombaRadius)
            .attr('cx', 0)
            .attr('cy', 0);

        innerG.append('circle')
            .attr('class', 'head')
            .attr('r', headRadius)
            .attr('cx', roombaRadius)
            .attr('cy', 0);

        innerG.append('text')
            .attr('class', 'label')
            .attr('text-anchor', 'middle')
            .attr('alignment-baseline', 'middle')
            .text(d => d.id);

        g.append('text').attr('class', 'energy');

        g.transition()
            .duration(2000)
            .style('opacity', 1);

        for (const player of players){
            const io = player.io;

            io.moveAngle = null;
            io.shock = false;

            io.positions = playerPositions;
            io.arena = arena;

            // read-only self-visibility for the player
            io.energy = player.energy;
            io.position = playerPositions[player.id];
            io.playerId = player.id;

            try {
            	player.iterator.next();            	
            }
            catch (e){
            	console.error(`player ${player.id} threw an error`, e);
            	player.energy = 0;
            }

            if (io.shock){
                if (player.energy <= shockEnergyCost){
                    io.shock = false;
                }
                else{
                    player.energy -= shockEnergyCost;
                }
            }

            if (typeof io.moveAngle === 'number'){
                const degrees = io.moveAngle;

                player.position.x += speed * Math.cos(degrees * Math.PI / 180);
                player.position.y += speed * Math.sin(degrees * Math.PI / 180);
            }

            player.position.x = constrainPosition(io.arena.width, player.position.x);
            player.position.y = constrainPosition(io.arena.height, player.position.y);
        }

        let collisionDetected;
        do {
        	collisionDetected = false;

	        var quad = d3.quadtree()
	        	.x(player => player.position.x)
	        	.y(player => player.position.y)
	        	.addAll(players);

	        for (const player of players){
	        	const pos = player.position;
	        	quad.visit(function(node, x0, y0, x1, y1){
	        		if (!node.length){
		        		do {
			        		const otherPlayer = node.data;
			        		if (otherPlayer.id != player.id){
			        			const otherPos = otherPlayer.position;
			        			const overlapAmount = calculateOverlap(pos.x, pos.y, roombaRadius, otherPos.x, otherPos.y, roombaRadius);
			        			if (overlapAmount > 0){
			        				collisionDetected = true;
			        				const move = overlapAmount / 2 + (Math.random() * 5);
			        				const angle = calculateAngle(pos.x, pos.y, otherPos.x, otherPos.y);
			        				pos.x += move * Math.cos(angle);
			        				pos.y += move * Math.sin(angle);
			        				otherPos.x -= move * Math.cos(angle);
			        				otherPos.y -= move * Math.sin(angle);
			        			}
			        		}
		        		} while (node = node.next);
	        		}
	        		return pos.x - roombaRadius >= x1 || pos.y - roombaRadius >= y1 || pos.x + roombaRadius < x0 || pos.y + roombaRadius < y0; 
	        	});
	        }
	  	} while (collisionDetected);

        dataJoin.attr('transform', player => `translate(${player.position.x},${player.position.y})`);

        dataJoin.selectAll('.inner')
            .attr('transform', player => `rotate(${Math.floor(player.io.faceAngle)})`)
            .each(function(player){
                const pos = container.node().createSVGPoint();
                pos.x = roombaRadius;
                pos.y = 0;

                player.headPosition = pos.matrixTransform(this.getCTM());
            });

        dataJoin.classed('shock', player => player.io.shock);

        dataJoin.classed('shocked', player => {
            let shocked = false;
            for (const other of players){
                if (!other.io.shock || other.id == player.id){
                    continue;
                }

                const pos = player.position;
                const otherPos = other.headPosition;

                if (calculateOverlap(pos.x, pos.y, roombaRadius, otherPos.x, otherPos.y, headRadius)){
                    shocked = true;
                    player.energy -= shockDamage;
                }
            }

            return shocked;
        });

        dataJoin.each(function(player){
            d3.select(this)
            	.select('.energy')
            	.text(player.energy < 0 ? '' : Math.trunc(player.energy));
        });

        await timeout(frameRate);

        let i = 0;
        while (i < players.length){
            const player = players[i];
            if (player.energy <= 0){
                players.splice(i, 1);
            }
            else {
                player.energy = Math.min(startingEnergy, player.energy + healingRate);
                i++;
            }
        }
    }

    console.warn('stopped');
}

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

run();

/*

game code above   ↑↑↑↑↑
player code below ↓↓↓↓↓

*/

function* stupidRoomba(io){
    const angerLevel = 0.1;
    while (true){
        io.faceAngle += Math.random() * 20 - 10;
        io.moveAngle = io.faceAngle;
        io.shock = Math.random() < angerLevel;
        yield;
    }
}

for (var i = 0; i < 20; i++){
    addPlayer(stupidRoomba);
}

function* smarterRoomba(io){
    const strikingDistance = roombaRadius * 2.2;
    let lastIdAttacked = null;
	while (true){
		const others = [];
		for (var otherPlayerId in io.positions){
			if (otherPlayerId != io.playerId){
				const otherPosition = io.positions[otherPlayerId];
				others.push({
                    playerId: otherPlayerId,
					distance: calculateDistance(io.position.x, io.position.y, otherPosition.x, otherPosition.y),
					position: otherPosition
				});
			}
		}

		if (others.length == 0){
			// victory dance
			while (true){
				for (var i = 0; i < 120; i++){
					io.faceAngle += 5;
					yield;
				}

				for (var i = 0; i < 120; i++){
					io.faceAngle -= 5;
					yield;
				}
			}
		}

        var enemy = null;

        if (lastIdAttacked){
            const lastEnemy = others.find(other => other.playerId == lastIdAttacked);
            if (lastEnemy && lastEnemy.distance < strikingDistance){
                enemy = lastEnemy;
            }
        }

        if (!enemy){
            others.sort((a, b) => a.distance - b.distance);
            enemy = others[0];
        }

		io.faceAngle = calculateAngle(enemy.position.x, enemy.position.y, io.position.x, io.position.y) * (180/Math.PI);

		if (io.energy > Math.random() * 100 + 200){
			io.moveAngle = io.faceAngle;
			if (enemy.distance < strikingDistance){
				io.shock = true;
                lastIdAttacked = enemy.playerId;
			}
			yield;
		}
		else {
			const c = Math.random() * 3 + 1;
			for (var i = 0; i < c; i++){
				io.moveAngle = io.faceAngle - 180;
				yield;
			}
		}
	}
}

addPlayer(smarterRoomba);
addPlayer(smarterRoomba);
addPlayer(smarterRoomba);
addPlayer(smarterRoomba);
</script>
</body>
</html>
