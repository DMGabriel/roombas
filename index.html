<!DOCTYPE html>
<head>
<title>Roomba Battle</title>

<style>
.player .body {
	fill: rgb(192, 192, 255);
}

.player.shocked .body {
	fill: orange;
}

.player .head {
	fill: rgb(100, 100, 255);
}

.player.shock .head {
	fill: red;
	stroke: red;
	stroke-width: 4px;
}

.player text {
	font-family: monospace;	
}

.player text.label {
	fill: white;
	font-weight: bold;
	font-size: 32px;
	text-decoration: underline;
}

.player text.energy {
	fill: red;
	font-size: 24px;
	transform: translate(40px, 40px);
}

#container {
    position: fixed;
    top: 0px;
    left: 0px;
    width: 100vw;
    height: 100vh;
}
</style>
</head>
<body>

<script src="https://d3js.org/d3.v4.min.js"></script>

<svg id='container'></svg>
<button id='stop' style='position: fixed'>Stop</button>

<script>
const roombaRadius = 60;
const headRadius = roombaRadius / 9;
const startingEnergy = 1000;
const shockDamage = 100;
const healingRate = 3;
const speed = 10;
const frameRate = Math.floor(1000 / 30);
const players = [];

var nextPlayerId = 10;

function addPlayer(generator){
	const player = {
		id: nextPlayerId++,
		energy: startingEnergy,
		position: {
			x: Math.floor(Math.random() * window.innerWidth),
			y: Math.floor(Math.random() * window.innerHeight)
		},
		io: {
			faceAngle: 0,
		}
	};

	player.iterator = generator(player.io);

	players.push(player);
}

function constrainPosition(max, actual){
	const padding = roombaRadius;
	max -= padding;

	if (actual > max){
		return max;
	}
	else if (actual < padding){
		return padding;
	}
	else {
		return actual;
	}
}

function areOverlapping(x1, y1, r1, x2, y2, r2){
	return Math.sqrt(((x2 - x1)**2) + ((y2 - y1)**2)) < r1 + r2; // pythagorean
}

var stopped = false;
document.getElementById('stop').addEventListener('click', () => stopped = true);

const container = d3.select('#container');

async function run(){
	while (!stopped){
		const playerPositions = Object.freeze(
			players
			.map(p => Object.freeze({
				id: p.id,
				position: Object.freeze(Object.assign({}, p.position))
			}))
		);

		const arena = Object.freeze({
			width: window.innerWidth,
			height: window.innerHeight
		});

		const dataJoin = container.selectAll('.player').data(players, d => d.id);

		dataJoin.exit().remove();

		const g =
			dataJoin.enter()
			.append('g')
				.attr('class', 'player')
				.style('opacity', 0);

		const innerG = g.append('g').attr('class', 'inner');

		innerG.append('circle')
			.attr('class', 'body')
			.attr('r', roombaRadius)
			.attr('cx', 0)
			.attr('cy', 0);

		innerG.append('circle')
			.attr('class', 'head')
			.attr('r', headRadius)
			.attr('cx', roombaRadius)
			.attr('cy', 0);

		innerG.append('text')
			.attr('class', 'label')
			.attr('text-anchor', 'middle')
			.attr('alignment-baseline', 'middle')
			.text(d => d.id);

		g.append('text')
			.attr('class', 'energy')
			.attr('text-anchor', 'middle')
			.attr('alignment-baseline', 'middle')
			//.attr('transform', 'translate(10, 10)')
			.text(d => d.id);

		g.transition('fadein')
			.duration(2000)
			.style('opacity', 1);

		for (let player of players){
			const io = player.io;

			io.moveAngle = null;
			io.shock = false;

			io.positions = playerPositions;
			io.arena = arena;

			io.energy = player.energy; // so the player can see their own energy count

			player.iterator.next();

			if (typeof io.moveAngle === 'number'){
				const degrees = io.moveAngle;

				player.position.x =
					constrainPosition(
						io.arena.width,
						player.position.x + (speed * Math.cos(degrees * Math.PI / 180))
					);

				player.position.y =
					constrainPosition(
						io.arena.height,
						player.position.y + (speed * Math.sin(degrees * Math.PI / 180))
					);
			}
		}

		container.selectAll('.player').attr('transform', player => `translate(${player.position.x},${player.position.y})`);
		container.selectAll('.inner').attr('transform', player => `rotate(${Math.floor(player.io.faceAngle)})`);
		dataJoin.classed('shock', player => player.io.shock);
		dataJoin.classed('shocked', player => {
				let shocked = false;
				for (let other of players){
					if (!other.io.shock || other.id == player.id){
						continue;
					}

					const pos = player.position;
					const otherPos = other.position;

					if (areOverlapping(pos.x, pos.y, roombaRadius, otherPos.x, otherPos.y, roombaRadius)){
						shocked	= true;
						player.energy -= shockDamage;
					}
				}

				return shocked;
		});

		dataJoin.each(function(player){
			d3.select(this).select('.energy').text(player.energy);
		});

		await timeout(frameRate);

		let i = 0;
		while (i < players.length){
			const player = players[i];
			if (player.energy <= 0){
				players.splice(i, 1);
			}
			else {
				i++;
				player.energy = Math.min(startingEnergy, player.energy + healingRate);
			}
		}
	}

	console.warn('stopped');
}

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

run();

/*
game code above   ↑↑↑↑↑
player code below ↓↓↓↓↓
*/



function* samplePlayer1(io){
	const angerLevel = 0.1;
	while (true){
		io.faceAngle += Math.random() * 20 - 10;
		io.moveAngle = io.faceAngle;
		if (Math.random() < angerLevel){
			io.shock = true;
		}
		yield;
	}
}

for (var i = 0; i < 10; i++){
		addPlayer(samplePlayer1);
}

</script>
</body>
</html>
